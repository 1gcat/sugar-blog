# 在浏览器中输入URL到页面渲染的整个过程

## 读取缓存
操作系统会首先在本地缓存中查询域名对应的IP
* 有:查找到后直接访问该ip
* 没有:进行**DNS解析**

## DNS解析
去系统配置的 DNS 服务器中查询该域名对应的具体的 IP地址
* 有:与对应地址开始建立TCP链接
* 没有:去 DNS 根服务器查询

## 建立TCP连接
*可以简述建立TCP链接的3次握手*
1. ``客户端``向``服务端``发送请求报文
2. ``服务端``收到请求报文,同意连接则向``客户端``发送一个应答
3. ``客户端``收到``服务端``的应答,并告知``服务端``我准备好了

## 判断是否是Https请求
**是:进行``TLS握手``**

**基本过程**
1. 客户端向服务器端索要并验证公钥
2. 双方协商生成”对话密钥”
3. 双方采用”对话密钥”进行加密通信

**详细握手过程**
1. 客户端发出请求:
   * 一个随机值(用于生成对话秘钥)
   * 支持的协议
   * 支持加密方式
   * 支持压缩的方法
2. 服务端收到客户端的请求，向客户端发出回应:
   * 一个随机值(用于生成对话秘钥)
   * 确定使用的协议
   * 确定使用的加密方式
   * 发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，如果证书没问题,向服务端发送一个请求:
   * 生成一个随机值(用证书公钥加密)
   * 编码改变通知(随后的信息将使用双方商定的加密方法和秘钥发送)
   * 客户端握手结束通知(前面发送的所有内容的hash值，用来提供给服务器校验)
4. 服务端最后响应
   * 服务器收到客户端的第三个随机数之后(用私钥解密)结合之前的两个明文随机数，计算生成本次会话所用的"会话密钥"
   * 编码改变通知(随后的信息都将用双方商定的加密方法和密钥发送)
   * 服务器握手结束通知(前面发送的所有内容的hash值，用来提供给客户端校验)

在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。

**否:发起Http请求**
## 发送HTTP请求
向服务端正式发送http请求
## 返回HTTP报文
服务器处理收到的请求,解析其中的参数,身份鉴权等,然后查询数据库

服务器处理请求然后响应结果,然后返回Http报文

**判断状态码是什么?**

* 200:继续解析
* 4xx 或 5xx: 报错
* 3xx:重定向

如果是**gzip**格式的话会先解压一下，然后通过文件的编码格式去解码文件

## 浏览器解析渲染页面

1. 解析HTML(超文本标记语言)-->DOM(文档对象模型)树,解析CSS(层叠样式表)-->CSSOM(CSS对象模型)树
   * 遇到 script 标签的话，会判断是否存在 async 或者 defer属性
      * async:并行进行下载,下载完成后并执行js
      * defer:先下载文件，然后等待 HTML 解析完成后顺序执行。
      * 如果都没有:就会阻塞住渲染流程直到 JS 执行完毕
2. DOM树 + CSSOM树 --> Render Tree(渲染树):CSSOM 树和 DOM 树构建完成后开始生成渲染树
3. 回流(Layout):根据生成的渲染树,回流得到可见节点的几何信息(位置,尺寸)
   * 计算可见的Dom节点在设备视口的位置和尺寸,这个计算阶段就是回流
   * 为了知道每个可见节点在视口的确切大小和位置,浏览器从渲染树的根节点进行遍历
4. 重绘(Painting):根据渲染树与回流得到的节点几何信息,得到节点的绝对像素
   * 经过生成的渲染树和回流阶段,得到了所有可见节点具体的几何信息与样式,然后将渲染树的每个节点转换成屏幕上的实际像素,这个阶段就叫重绘节点
5. 将像素发送给GPU绘制,合成图层,然后展示在页面上

**在下载文件时，使用 HTTP/2 协议(多路复用)可以解决队头阻塞的问题**

## 断开TCP连接
断开进行4此握手
1. ``客户端``对``服务端``发送释放连接的请求
2. ``服务端``收到``客户端``的请求后,告知应用层释放连接
3. ``服务端``将数据发送完毕后,再向``客户端``发送释放连接请求
4. ``客户端``收到释放请求后,并向``服务端``发送确认释放的应答,同意释放