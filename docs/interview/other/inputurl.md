# 在浏览器中输入URL到页面渲染的整个过程
## 构建请求行
```text
GET   /     HTTP/1.1
方法  请求路径 请求的协议/版本
```

## 查找强缓存
检查资源是否存在强缓存,存在的话直接进行资源解析

## 读取DNS缓存
操作系统会首先在本地缓存中查询域名对应的IP,查找到后直接访问该ip,没有则进行下一步

## DNS解析
* 去系统配置的 DNS 服务器中查询该域名对应的具体的 IP。
* 如果这时候还没有的话，会直接去 DNS 根服务器查询

## 建立TCP连接
简述建立TCP链接的3次握手
1. ``客户端``向``服务端``发送请求报文
2. ``服务端``收到请求报文,同意连接则向``客户端``发送一个应答
3. ``客户端``收到``服务端``的应答,并告知``服务端``我准备好了

TCP 的一些特性
* 建立连接需要进行三次握手
* 断开连接都需要四次握手
* 在传输数据的过程中，通过各种算法保证数据的可靠性
* 相比 UDP 来说不那么的高效。

**判断是否是Https请求?**
如果是需要进行``TLS握手``
1. 客户端发送一个**随机值**以及需要的**协议**和**加密方式**。
2. 服务端收到客户端的**随机值**，自己也产生一个**随机值**，并根据客户端需求的**协议**和**加密方式**来使用对应的方式，并且发送自己的**证书**（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的**证书**并验证是否有效，**验证通过**会再生成一个**随机值**，通过服务端发送的证书中的**公钥**去加密这个随机值并发送给服务端
4. 服务端收到加密过的随机值并使用**私钥**解密获得第三个随机值，这时候两端都拥有了**三个随机值**，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密
## 发送HTTP请求

## 返回HTTP报文
服务器处理请求响应结果,并返回Http报文

**判断状态码是什么?**

如果是 200 那就继续解析，如果 4xx 或 5xx 的话就会报错，如果 3xx 进行重定向

如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

## 浏览器解析渲染页面

1. 解析HTML-->DOM树
   * 标记化:词法分析
   * 构建DOM树:语法分析
3. 解析CSS-->CSSOM树
   * link标签引用
   * style标签中的样式
   * 元素的内嵌style属性

* 如果遇到 script 标签的话，会判断是否存在 async 或者 defer属性
   * async:并行进行下载并执行js
   * defer:先下载文件，然后等待 HTML 解析完成后顺序执行。
   * 如果都没有:就会阻塞住渲染流程直到 JS 执行完毕
1. DOM树 + CSSOM树 --> Render Tree(渲染树):CSSOM 树和 DOM 树构建完成后开始生成渲染树
2. 回流(Layout):根据生成的渲染树,回流得到节点的几何信息(位置,尺寸)
   * 计算可见的Dom节点在设备视口的位置和尺寸,这个计算阶段就是回流
   * 为了知道每个可见节点在视口的确切大小和位置,浏览器从渲染树的根节点进行遍历
3. 重绘(Painting):根据渲染树与回流得到的节点几何信息,得到节点的绝对像素
   * 经过生成的渲染树和回流阶段,得到了所有可见节点具体的几何信息与样式,然后将渲染树的每个节点转换成屏幕上的实际像素,这个阶段就叫重绘节点
4. 将像素发送给GPU绘制,合成图层,然后展示在页面上

## 断开TCP连接

1. ``客户端``对``服务端``发送释放连接的请求
2. ``服务端``收到``客户端``的请求后,告知应用层释放连接
3. ``服务端``将数据发送完毕后,再向``客户端``发送释放连接请求
4. ``客户端``收到释放请求后,并向``服务端``发送确认释放的应答,同意释放