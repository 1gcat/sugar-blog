# 浏览器渲染原理

## 解析HTML
浏览器接收到 HTML 文件并转换为 DOM 树

1. 在网络中传输的内容其实都是0和1这些字节数据。当浏览器接收到这些字节数据以后，会将这些字节数据转换为字符串，也就是程序员所书写的代码。
2. 将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。
3. 标记转换为 Node，根据不同 Node 之前的联系构建为一棵 DOM 树。
4. 在解析 HTML 文件的时候，当遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件

## 解析CSS
将 CSS 文件转换为 CSSOM 树

在这一过程中，浏览器会确定下每一个节点的样式是什么(这一过程其实是很消耗资源的)。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器会递归 CSSOM 树，然后确定具体的元素到底是什么样式。
* 尽可能的避免写过于具体的 CSS 选择器
* 对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。

## 生成渲染树

生成 DOM 树和 CSSOM 树之后，就需要将这两棵树组合为渲染树

![图片](http://img.cdn.sugarat.top/mdImg/MTU4MzMwNTYyNTE4Ng==583305625186)

渲染树只会包括需要显示的节点和这些节点的样式信息

**不显示的节点**
* css:display:nonoe
* 标签:script,link,meta等等

当浏览器生成渲染树以后，就会根据渲染树来进行布局(回流重绘),然后调用 GPU 绘制，合成图层

## 常见问题
### 1.为什么操作 DOM 慢?

 DOM 是属于**渲染引擎**中的东西，而 JS 又是 **JS 引擎**中的。通过 JS 操作 DOM 的时候，这个操作涉及到了两个线程之间的通信，必然会带来一些性能上的损耗。操作 DOM 次数一多，就等同于一直在进行线程之间的通信，并且操作DOM可能还会带来重绘回流的影响，所以也就导致了性能上的问题。


### 2.展示大量的数据,如何实现页面不卡顿?
虚拟滚动(即懒加载的方式)

原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

### 3.什么情况阻塞渲染?
* HTML 和 CSS 肯定会阻塞渲染
  * 提升渲染速度:降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。
* 解析到 script 标签时，判断是否包含defer或者async
  * defer: JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行
    * 可以把 script 标签放在任意位置。
  * async:JS 文件下载和解析不会阻塞渲染
    * 下载完后就执行
    * 对于没有任何依赖的 JS 文件可以加上 async 属性
  * 两者都不含有:暂停构建 DOM，下载完成后才会从暂停的地方重新开始
    * 建议将 script 标签放在 body 标签底部
  
### 4.重绘（Repaint）和回流（Reflow）?
* 回流:计算可见的Dom节点在设备视口的位置和尺寸,这个计算阶段就是回流
  * 当节点需要更改外观而不会影响布局时，触发重绘
* 重绘:经过生成的渲染树和回流阶段,得到了所有可见节点具体的几何信息与样式,然后将渲染树的每个节点转换成屏幕上的实际像素,这个阶段就叫重绘节点
  * 布局或者节点的几何属性改变时,触发回流。

**回流必定会发生重绘，重绘不一定会引发回流!**

回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列的回流。

以下几个动作可能会导致性能问题：
* 改变窗口(window)大小
* 改变字体
* 添加或删除样式
* 文字改变
* 定位或者浮动
* 盒模型

**参与Event Loop**

* 当 Eventloop 执行完 Microtasks(微任务)后,判断document是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
* 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且**自带节流**功能。
* 判断是否触发了 media query
* 更新动画并且发送事件
* 判断是否有全屏操作事件
* 执行 requestAnimationFrame 回调
* 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
* 更新界面

### 5.如何减少重绘和回流?
* 使用 transform 替代 top
* 使用 visibility 替换 display: none
  * 因为前者只会引起重绘，后者会引发回流（改变了布局）
* 不要把节点的属性值放在一个循环里当成循环里的变量
* 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用``requestAnimationFrame``
* CSS 选择符从右往左匹配查找，避免节点层级过多

### 6.在不考虑缓存和优化网络协议的前提下，考虑可以通过哪些方式来最快的渲染页面?
1. 考虑文件大小
2. 考虑script 标签的使用
3. 从 CSS、HTML 的代码书写上来考虑
4. 需要下载的内容是否需要在首屏使用上来考虑

:::tip 参考
[浏览器|前端进阶之道](https://yuchengkai.cn/docs/frontend/browser.html)
:::

<tongji/>